A Dive into Building a Decentralized Identity Management on zkSync

## Table of Contents:

1. [Introduction](#introduction)
2. [Project Setup](#project-setup)
3. [Smart Contract Overview](#smart-contract-overview)
4. [Struct](#smart-contract-struct)
5. [Mapping and Events](#mapping-and-events)
6. [Identity Creation](#identity-creation)
7. [Update Identity](#update-identity)
8. [Delete Identity](#delete-identity)
9. [Verify Identity](#verify-identity)
10. [Revoke Identity](#revoke-identity)
10. [Retrieve Identity](#retrieve-identity)
10. [Retrieve Identity](#retrieve-identity)
11. [Check Identity Verification](#check-identity-verification)
12. [Log Identity Actions](#log-identity-actions)
14. [Compiling and Writing Tests](#compiling-and-writing-tests)
15. [Deployment](#deployment)
16. [Frontend Integration](#frontend-integration)

## Introduction

A decentralized identity management has emerged as a pivotal component for enhancing security, privacy, and user control. However, zkSync, a Layer 2 scaling solution for Ethereum, offers a promising avenue for addressing these challenges. By leveraging zero-knowledge proofs, zkSync provides high throughput and low-cost transactions while maintaining the security and decentralization of the Ethereum network.

In this article, we will delve into the intricacies of building a decentralized identity management system on zkSync and a step-by-step guide to implementing a robust identity management solution on zkSync era. This includes smart contract development, writing tests and deployment on zkSync sepolia testnet.

## Project Setup

To setup the project, we will scaffold it with [zkSync cli](https://docs.zksync.io/build/tooling/zksync-cli/commands/create.html#contracts) for easy set up.

Head over to your command prompt or terminal and run the code below:

`npx zksync-cli create`

You will be prompted to enter your project's name. You can enter your desired project's name, in our case `IdentityManagement`.

Next, you will be prompted to select the type of project. Select `Contracts` and proceed. 

After that, select `Ethers V6` as ethereum framework and select `Hardhat + Solidity` as Template.

You will be prompted to enter `private key` or set it later. For this tutorial,leave it blank and continue.

Finally, select your desired package manage to begin installations.

This will create a new zkSync era project named `IdentityManagement`. Some examples contracts,tests and deployment will be generated by default. However, for the purposes of this tutorial, we don't need the example contracts related files. So, proceed by removing all the files inside the /contracts , /test folders manually or by running the following commands:

`cd IdentityManagement `
`rm -rf ./contracts/*`
`rm -rf ./test/*`
`rm -rf ./deploy/erc20 && rm -rf ./deploy/nft`

Finally, create a file named `IdentityManagement.sol` inside your `contracts` folder.

## Smart Contract Overview

The Identity `identityManagement` smart contract serves as the backbone of our decentralized identity management system. This contract, written in Solidity, allows users to manage their identities securely on the zkSync network. 

Below is the the complete smart contract code for this project :

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract IdentityManagement {

    /**
     * @dev Struct representing an identity.
     * @param user The address of the user.
     * @param name The name of the user.
     * @param email The email of the user.
     * @param isVerified Indicates if the identity is verified.
     * @param exists Indicates if the identity exists.
     */
    struct Identity {
        address user;
        string name;
        string email;
        bool isVerified;
        bool exists;
    }

    /// Mapping from user address to their identity
    mapping(address => Identity) public identities;

    /// Event emitted when a new identity is added
    event IdentityAdded(address indexed user, string name, string email);

    /// Event emitted when an identity is updated
    event IdentityUpdated(address indexed user, string name, string email);

    /// Event emitted when an identity is deleted
    event IdentityDeleted(address indexed user);

    /// Event emitted when an identity is verified
    event IdentityVerified(address indexed user);

    /// Event emitted when an identity is revoked
    event IdentityRevoked(address indexed user);

    /// Event emitted when an identity-related action is logged
    event IdentityActionLogged(string action);

    /**
     * @dev Adds a new identity for the caller.
     * @param _name The name of the user.
     * @param _email The email of the user.
     */
    function addIdentity(string memory _name, string memory _email) public {
        require(!identities[msg.sender].exists, "Identity already exists");
        identities[msg.sender] = Identity({
            user: msg.sender,
            name: _name,
            email: _email,
            isVerified: false,
            exists: true
        });
        emit IdentityAdded(msg.sender, _name, _email);
        logIdentityAction("Identity Added");
    }

    /**
     * @dev Updates the identity of the caller.
     * @param _name The new name of the user.
     * @param _email The new email of the user.
     */
    function updateIdentity(string memory _name, string memory _email) public {
        require(identities[msg.sender].exists, "Identity does not exist");
        identities[msg.sender].name = _name;
        identities[msg.sender].email = _email;
        emit IdentityUpdated(msg.sender, _name, _email);
        logIdentityAction("Identity Updated");
    }

    /**
     * @dev Deletes the identity of the caller.
     */
    function deleteIdentity() public {
        require(identities[msg.sender].exists, "Identity does not exist");
        delete identities[msg.sender];
        emit IdentityDeleted(msg.sender);
        logIdentityAction("Identity Deleted");
    }

    /**
     * @dev Verifies the identity of the caller.
     */
    function verifyIdentity() public {
        require(identities[msg.sender].exists, "Identity does not exist");
        identities[msg.sender].isVerified = true;
        emit IdentityVerified(msg.sender);
        logIdentityAction("Identity Verified");
    }

    /**
     * @dev Revokes the verification of the identity of the caller.
     */
    function revokeIdentity() public {
        require(identities[msg.sender].exists, "Identity does not exist");
        identities[msg.sender].isVerified = false;
        emit IdentityRevoked(msg.sender);
        logIdentityAction("Identity Revoked");
    }

    /**
     * @dev Retrieves the identity of a given user.
     * @param _user The address of the user.
     * @return The identity of the user.
     */
    function getIdentity(address _user) public view returns (Identity memory) {
        require(identities[_user].exists, "Identity does not exist");
        return identities[_user];
    }

    /**
     * @dev Checks if a given user's identity is verified.
     * @param _user The address of the user.
     * @return True if the user's identity is verified, false otherwise.
     */
    function isIdentityVerified(address _user) public view returns (bool) {
        require(identities[_user].exists, "Identity does not exist");
        return identities[_user].isVerified;
    }

    /**
     * @dev Logs an identity-related action.
     * @param action The action to log.
     */
    function logIdentityAction(string memory action) internal {
        emit IdentityActionLogged(action);
    }
}
```

## Smart Contract Struct

The `Identity` struct encapsulates user information, comprising the following fields:

- **`address user`**: address uniquely identifying the user.
- **`string name`**: User's name.
- **`string email`**: User's email address.
- **`bool isVerified`**: Indicates if the user's identity has been verified.
- **`bool exists`**: Indicates if the identity record exists in the system.

This struct provides a structured way to manage and store user identities, ensuring efficient and secure operations like adding, updating, verifying, and deleting identities within the contract.

## Mapping and Events

The mapping, `identities`, link user addresses to their respective `Identity` structs, facilitating efficient management of user identities.

1. **`IdentityAdded`**: Emitted when a new identity is added.
2. **`IdentityUpdated`**: Emitted when an existing identity is updated.
3. **`IdentityDeleted`**: Emitted when an identity is deleted.
4. **`IdentityVerified`**: Emitted when an identity is verified.
5. **`IdentityRevoked`**: Emitted when an identity's verification is revoked.
6. **`IdentityActionLogged`**: Emitted when any identity-related action is logged.

## Identity Creation

```solidity
 function addIdentity(string memory _name, string memory _email) public {
        require(!identities[msg.sender].exists, "Identity already exists");
        identities[msg.sender] = Identity({
            user: msg.sender,
            name: _name,
            email: _email,
            isVerified: false,
            exists: true
        });
        emit IdentityAdded(msg.sender, _name, _email);
        logIdentityAction("Identity Added");
    }
```

The `addIdentity` function allows a user to create a new identity. It performs the following actions:

1. Checks that the user's identity does not already exist.
2. Creates a new `Identity` struct for the user with the provided name and email, setting `isVerified` to `false` and `exists` to `true`.
3. Updates the `identities` mapping with the new identity.
4. Emits the `IdentityAdded` event.
5. Logs the action "Identity Added" using the `logIdentityAction` function.

## Update Identity

```solidity
  function updateIdentity(string memory _name, string memory _email) public {
        require(identities[msg.sender].exists, "Identity does not exist");
        identities[msg.sender].name = _name;
        identities[msg.sender].email = _email;
        emit IdentityUpdated(msg.sender, _name, _email);
        logIdentityAction("Identity Updated");
    }
```
The `updateIdentity` function allows a user to update their existing identity's name and email. It performs the following actions:

1. Checks that the user's identity exists.
2. Updates the `name` and `email` fields of the user's existing identity with the provided values.
3. Emits the `IdentityUpdated` event.
4. Logs the action "Identity Updated" using the `logIdentityAction` function.

## Delete identity

```solidity
   function deleteIdentity() public {
        require(identities[msg.sender].exists, "Identity does not exist");
        delete identities[msg.sender];
        emit IdentityDeleted(msg.sender);
        logIdentityAction("Identity Deleted");
    }
```
The `deleteIdentity` function allows a user to delete their existing identity. It performs the following functions actions:

1. Checks that the user's identity exists.
2. Deletes the user's identity from the `identities` mapping.
3. Emits the `IdentityDeleted` event.
4. Logs the action "Identity Deleted" using the `logIdentityAction` function.

## Verify Identity

```solidity
  function verifyIdentity() public {
        require(identities[msg.sender].exists, "Identity does not exist");
        identities[msg.sender].isVerified = true;
        emit IdentityVerified(msg.sender);
        logIdentityAction("Identity Verified");
    }
```

The `verifyIdentity` function allows a user to verify their identity. It performs the following functions actions :

1. Checks that the user's identity exists.
2. Sets the `isVerified` field of the user's identity to `true`.
3. Emits the `IdentityVerified` event.
4. Logs the action "Identity Verified" using the `logIdentityAction` function.

## Revoke Identity 

```solidity
  function revokeIdentity() public {
        require(identities[msg.sender].exists, "Identity does not exist");
        identities[msg.sender].isVerified = false;
        emit IdentityRevoked(msg.sender);
        logIdentityAction("Identity Revoked");
    }
```

The `revokeIdentity` function allows a user to revoke their identity verification.

1. **Checks that the user's identity exists**.
2. **Sets the `isVerified` field of the user's identity to `false`**, marking it as not verified.
3. **Emits the `IdentityRevoked` event**.
4. **Logs the action "Identity Revoked"** using the `logIdentityAction` function.

## Retrieve Identity

```solidity
 function getIdentity(address _user) public view returns (Identity memory) {
        require(identities[_user].exists, "Identity does not exist");
        return identities[_user];
    }
```
The `getIdentity` function retrieves the identity details for a specified user address:

1. **Checks that the user's identity exists** in the `identities` mapping.
2. **Returns the identity details** for the specified address.

## Check Identity Verification 

```solidity
    function isIdentityVerified(address _user) public view returns (bool) {
        require(identities[_user].exists, "Identity does not exist");
        return identities[_user].isVerified;
    }
```

The `isIdentityVerified` function checks whether a specified user's identity is verified:

1. **Checks that the user's identity exists** in the `identities` mapping.
2. **Returns the verification status** (`true` or `false`) of the specified user's identity.

## Log Identity Actions

```solidity
function logIdentityAction(string memory action) internal {
        emit IdentityActionLogged(action);
    }
```

The `logIdentityAction` function logs an identity-related action:

1. **Emits the `IdentityActionLogged` event** with the provided action string.
2. **Internal function**, meaning it can only be called within the contract itself.


## Compiling and Writing Tests

To begin compiling our smart contract using `zkSync cli`, run the below command:

`npm run compile` if you are using Yarn, run `yarn compile`.

If it compiles successfully, you should a similar output like the image below:

<img width="606" alt="4w-identity-compile" src="https://github.com/user-attachments/assets/d1793b51-4487-4c4c-89ed-b5ac6e70d131">

Next, proceed to writing tests for the smart contract. First, create a file `identityManagement.test.ts` and set up the context for the contract testing.

**Imports and Declarations:**
```typescript
import { expect } from 'chai';
import { getWallet, deployContract, LOCAL_RICH_WALLETS } from '../deploy/utils';
import { Contract, EventLog } from 'ethers';
import { Wallet } from 'zksync-ethers';
```

Next, proceed to initialize the wallets and deployment for testing purpose.

```typescript
  let identityManagement: Contract;
  let user1: Wallet;
  let user2: Wallet;
  let deployer : Wallet

  before(async () => {
    deployer = getWallet(LOCAL_RICH_WALLETS[0].privateKey);
    user1 = getWallet(LOCAL_RICH_WALLETS[1].privateKey);
    user2 = getWallet(LOCAL_RICH_WALLETS[2].privateKey);
    identityManagement = await deployContract("IdentityManagement", [], { wallet: deployer , silent: true });
  });

```

In the test setup for the `IdentityManagement` contract:

1. **Initialize Wallets**:
   - Three wallets are created:
     - `deployer` for deploying the contract.
     - `user1` and `user2` for interacting with the contract during tests.

2. **Deploy the Contract**:
   - The `IdentityManagement` contract is deployed using the `deployer` wallet, preparing the environment for subsequent tests.
  
### Test: Add identity

```typescript
    it("Should allow a user to add their own identity", async function () {
      await (identityManagement.connect(user1) as Contract).addIdentity("Alice", "alice@example.com");
      const identity = await (identityManagement.connect(user1) as Contract).getIdentity(user1.address);
      expect(identity.name).to.equal("Alice");
      expect(identity.email).to.equal("alice@example.com");
      expect(identity.isVerified).to.equal(false);
      expect(identity.exists).to.equal(true);
    });
```

This test confirms that a user can add their identity:

1. **User adds identity**: `user1` adds their identity with the name "Alice" and email "alice@example.com".
2. **Verify identity**: Checks that the added identity's details are correct:
   - Name: "Alice"
   - Email: "alice@example.com"
   - Not verified
   - Exists
   
### Test: Update identity

```typescript
    it("Should allow a user to update their own identity", async function () {
      await (identityManagement.connect(user1) as Contract).updateIdentity("Alice Updated", "aliceupdated@example.com");
      const identity = await (identityManagement.connect(user1) as Contract).getIdentity(user1.address);
      expect(identity.name).to.equal("Alice Updated");
      expect(identity.email).to.equal("aliceupdated@example.com");
    });
```

This test confirms that a user can update their identity:

1. **User updates identity**: `user1` updates their identity to "Alice Updated" with the email "aliceupdated@example.com".
2. **Verify updated identity**: Checks that the updated identity's details are correct:
   - Name: "Alice Updated"
   - Email: "aliceupdated@example.com"
  
### Test: Verify Identity

```typescript
   it("Should allow a user to verify their own identity", async function () {
      await (identityManagement.connect(user1) as Contract).verifyIdentity();
      const identity = await (identityManagement.connect(user1) as Contract).getIdentity(user1.address);
      expect(identity.isVerified).to.equal(true);
    });
```

This test confirms that a user can verify their identity:

1. **User verifies identity**: `user1` calls the `verifyIdentity` function.
2. **Verify status**: Checks that the `isVerified` field of `user1`'s identity is `true`.

### Test: Revoke Identity

```typescript
    it("Should allow a user to revoke their own identity", async function () {
      await (identityManagement.connect(user1) as Contract).revokeIdentity();
      const identity = await (identityManagement.connect(user1) as Contract).getIdentity(user1.address);
      expect(identity.isVerified).to.equal(false);
    });
```

This test confirms that a user can revoke their identity verification:

1. **User revokes identity verification**: `user1` calls the `revokeIdentity` function.
2. **Verify status**: Checks that the `isVerified` field of `user1`'s identity is `false`.


Below is the complete test code for this contract:

```typescript
import { expect } from 'chai';
import { getWallet, deployContract, LOCAL_RICH_WALLETS } from '../deploy/utils';
import { Contract, EventLog } from 'ethers';
import { Wallet } from 'zksync-ethers';

describe("IdentityManagement", function () {
  // We define a fixture to reuse the same setup in every test.

  let identityManagement: Contract;
  let user1: Wallet;
  let user2: Wallet;
  let deployer : Wallet

  before(async () => {
    deployer = getWallet(LOCAL_RICH_WALLETS[0].privateKey);
    user1 = getWallet(LOCAL_RICH_WALLETS[1].privateKey);
    user2 = getWallet(LOCAL_RICH_WALLETS[2].privateKey);
    identityManagement = await deployContract("IdentityManagement", [], { wallet: deployer , silent: true });
  });

  describe("identityManagement", function () {
    it("Should allow a user to add their own identity", async function () {
      await (identityManagement.connect(user1) as Contract).addIdentity("Alice", "alice@example.com");
      const identity = await (identityManagement.connect(user1) as Contract).getIdentity(user1.address);
      expect(identity.name).to.equal("Alice");
      expect(identity.email).to.equal("alice@example.com");
      expect(identity.isVerified).to.equal(false);
      expect(identity.exists).to.equal(true);
    });

    it("Should allow a user to update their own identity", async function () {
      await (identityManagement.connect(user1) as Contract).updateIdentity("Alice Updated", "aliceupdated@example.com");
      const identity = await (identityManagement.connect(user1) as Contract).getIdentity(user1.address);
      expect(identity.name).to.equal("Alice Updated");
      expect(identity.email).to.equal("aliceupdated@example.com");
    });

    it("Should allow a user to verify their own identity", async function () {
      await (identityManagement.connect(user1) as Contract).verifyIdentity();
      const identity = await (identityManagement.connect(user1) as Contract).getIdentity(user1.address);
      expect(identity.isVerified).to.equal(true);
    });

    it("Should allow a user to revoke their own identity", async function () {
      await (identityManagement.connect(user1) as Contract).revokeIdentity();
      const identity = await (identityManagement.connect(user1) as Contract).getIdentity(user1.address);
      expect(identity.isVerified).to.equal(false);
    });

  });
});
```

If all tests passed, you should see a similar result like the image below:
<img width="606" alt="4w-identity-test" src="https://github.com/user-attachments/assets/5582da35-c015-4b87-9cb3-d9ba427d826f">


## Deployment

Finally, let's deploy our smart contract to zksync sepolia testnet.

First, add your private key to the `.env` file in the root directory:

```
WALLET_PRIVATE_KEY=YOUR-PRIVATE-KEY
```

Note: Replace `YOUR-PRIVATE-KEY` with your actual private key. Ensure you have already obtained some [zkSync faucets](https://docs.zksync.io/ecosystem/network-faucets#sepolia-faucets).

Next, update `deploy.ts` inside `deploy` folder with the following code :

```typescript

import { deployContract } from "./utils";

// An example of a basic deploy script
// It will deploy a Greeter contract to selected network
// as well as verify it on Block Explorer if possible for the network
export default async function () {
  const contractArtifactName = "IdentityManagement";
  const constructorArguments = [];
  await deployContract(contractArtifactName, constructorArguments);
}

```

Finally, run `npm run deploy` to deploy your smart contract to zkSync sepolia testnet which will output a result like the one below:
<img width="590" alt="4w-identity-deploy" src="https://github.com/user-attachments/assets/4fc28a86-5f9c-49d7-a784-3a6458c0bf0d">

Congratulations! You have successfully deployed a contract.

## Frontend Integration

To get started, we have to decide which frontend framework we will be using. You can decide to use whichever one that works for you best. In this tutorial, we will be using Next js, a React framework.

Inside your project root, open your teminal and run these commands to set up your frontend.


`npx create-next-app@latest client`

This above command create a next js project in `client` folder.

Once you have successfully set up your project, there are few packages that we are going to install in order to interact with our smart contracts in the frontend. 

We will be installing `zksync-ethers` `ethers` and `bootstrap` and `react-toastify`. `zksync-ethers` and `ethers` will be needed to interact with our smart contract, `bootstrap` will be used to design the frontend interface while `react-toastify` will be used to handle notifications or alerts on the dApp.

Open your terminal and navigate into the `client` directory to insall these dependencies by running the commands below : 

`npm i zksync-ethers ethers bootstrap react-toastify`


After the installations are done, open the client folder and create a `variables` folder inside it. This folder will hold `abi.json` file and `address.json`. These two files are needed to connect to our smart contract.

Now, go ahead and create the two files. Next, copy the `abi` from your deployed contract's deployment and paste it inside the `abi.json`. Repeat the same process for your contract address.

Let's begin writing frontend code. Open your `page.jsx` inside the `app` directory and clear all the contents of the file.

To start with, add `use client` at the top level of the file. This directive helps to distinguish between server and client component in Next js. It ensures that the component is rendered on the client-side, allowing you to use client-side functionalities like React hooks (useState, useEffect, etc.), browser APIs, and event listeners.

Next, import the below dependencies. 

```typescript
import React, { useState, useEffect } from 'react';
import { ethers } from "ethers";
import { utils, BrowserProvider } from "zksync-ethers";
import { ToastContainer, toast, ToastOptions } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import 'bootstrap/dist/css/bootstrap.min.css';
import { Provider, Wallet } from 'zksync-ethers';
```

The next thing is to import `contract address` and `abi` from the `variables` folder we created earlier.

```javascript
const contractAddress = require('../variables/address.json');
const abi = require('../variables/abi.json');

```

Currently, your `page.jsx` should like the image below.
![page-head](https://github.com/user-attachments/assets/d7f92ae5-ad83-41a3-aac9-53ab71f53ca4)

Let's proceed to declare `Home` component where our frontend functionalities will reside.

```javascript
function Home() {

}
```

Inside the `Home` component, let's declare our state variables needed to manage the dApp's states.

```javascript
  const [provider, setProvider] = useState(null);
  const [signer, setSigner] = useState(null);
  const [contract, setContract] = useState(null);
  const [account, setAccount] = useState('');
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [identity, setIdentity] = useState(null);
  const [isIdentityFetched, setIsIdentityFetched] = useState(false);
````

- **`provider`**: Stores the blockchain provider, used to interact with the zkSync network.
- **`signer`**: Holds the signer object, representing an account that can sign transactions.
- **`contract`**: Stores the smart contract instance that will be interacted with.
- **`account`**: Contains the address of the connected user's account.
- **`name`**: Manages the name of the current user.
- **`email`**: Manages the user's email address for identification .
- **`identity`**: Stores the user's identity information.
- **`isIdentityFetched`**: A boolean flag indicating whether the user's identity has been successfully fetched or not.

These states that we declared collectively manage the connection to the blockchain, user information, and interaction with the smart contract.

Also,

